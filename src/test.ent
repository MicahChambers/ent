#/home/micahc/tools/ent/bin/ent
#
# Implements the following:
#
## Registering each subjects fmri images to the T1 image
#foreach t1 in subject:
#    foreach f in fmri:
#      flirt -in t1 -ref f -out t1_in_fmri -tfm trans.mat
#	   flirt -init trans.mat -inv f -out fmri_in_t1 
# 
#foreach t1 in subject:
#    foreach d in dti:
#      flirt -in t1 -ref d -out t1_in_fmri -tfm trans.mat
#
#combine corresponding elements from two lists
#foreach subject:
#	foreach f,d in zip(fmri,dti):
#		divide -i f -i d -o ratio
#
##register between corresponding fMRI across subjects (collapse subjects)
#foreach fmri:
#	flirt -in fsubj1 -ref fsubj2 -out fsubj1_in_fsubj2 -tfm trans.mat
#
#note wildcard should resolve to a single input
base=/datadir
prefix  =   {base}/{subject}/pipe   
subject=10107,10343,1
fmri=fmri_year1,fmri_year2
dti=dti_year1,dti_year2
prefix={base}/{subject}/pipe

# Types of lines:
#
# Variable declaration (use ',' for an array):
#	a=b[,c[,d...]]
#
# Declaration of input files:
#	uint[.int[.int]]:s[ource]:[file[,file[,...]]] = ({mvar}[*,{mvar}[*,{mvar}]])
#
#		either :i: or :input: may be used
#
#		where mvar are variables from variable declaration above that will be 
#		iterated through. Provinences can be combined using either '*' or ','
#		to determine how mvar variables will be iterated through. 
#
#		* will use
#			every possible combination of the two, ie: {subj}*{fmri} would generate
#			the 6 file pairs: 
#
#				(10107,fmri_year1),(10107,fmri_year2),(10343,fmri_year1),
#				(10343,fmri_year2),(1,fmri_year1),(1,fmri_year2)
#
#			hence the reason * is used, because the number of jobs generated is the
#			product of the length of the input metavars. Each pair would then be
#			used to fill in variables in the [file[,file...]] spec.
#		
#		, will pair up the inputs, but the variables MUST BE OF THE SAME LENGTH:
#			therefore {subj},{fmri} is incorrect because their lengths differ, but
#			
#			{fmri},{dti} will generate the following:
#			
#			(fmri_year1,dti_year1),(fmri_year2,dti_year2)
#		
#		() may be used combine, but only one operator type is allowed in a set of 
#			parenthesis.
#
# Declaration of a process
#	uint[.uint[...]]:p[roc]:[ftemp[,ftemp[...]]] = cmd {<inspec} {>outspec} {!<inspec} {!>outspec}
#
#		where 
#
#			either :p: or :proc: may be used
#
#			ftemp is a file postfix, the job number will be prefixed to 
#				provide a unique output
#
#			cmd is a command line program to run
#
#			{<inspec},{>outspec} variables are included on the command line,
#				and will be replaced with the corresponding input ( {<file} ) and
#				output ( {>file} )
#
#			{!<inspec},{!>outspec} variables are implicit (ie not included on
#				the command line), but should be generated by the cmd. So for
#				instance if the output is a directory, that gets filled with files
#				the dir should be: {>outdir} and the files should all be listed:
#				{!>outfile} {!>outfile}...
#
#			inspec is of the form 'jspec:i-j@prefix' where all arguments are optional. 
#				
#				jspec indicates a specific job which produces the 
#					output for the desired input, (default is the preceeding job spec)
#
#				i-j indicates a range of output numbers from the given jobspec, 
#					-j may be omitted to specify a single output
#				
#				@prefix indicates variables to prepend to each input from i-j, so
#					for instance {0-2@-i } would cause -i out0 -i out1 -i out2 -i 
#					to be added to the command line where out0,out1,out2 are outputs
#					of the previous job
#
#			outspec is identical in form to ftemp, and will be prepended with a 
#				with a job identifier
#			

#Comma indicates two inputs will be provided for everything in the 0 branch
#foreach t1 in subject:
#    foreach f in fmri:
#      flirt -in t1 -ref f -out t1_in_fmri -tfm trans.mat
#	   flirt -init trans.mat -inv f -out fmri_in_t1 
#
# ({base}*{fmri}*{subject})  - generates every possible combination:
# (/datadir,fmri_year1,10107),
# (/datadir,fmri_year1,10343),
# (/datadir,fmri_year1,1)
# (/datadir,fmri_year2,10107),
# (/datadir,fmri_year2,10343),
# (/datadir,fmri_year2,1)
#
# then this produces the following list of arguments: 
#	[(arg0_to_proc0,arg1_to_proc0), (arg0_to_proc1,arg1_to_proc1) ... ]
#
#[(/datadir/10107/fmri_year1*.nii.gz,	/datadir/10107/SAGMPRAGE*.nii.gz),
# (/datadir/10343/fmri_year1*.nii.gz,	/datadir/10343/SAGMPRAGE*.nii.gz),
# (/datadir/1/fmri_year1*.nii.gz,		/datadir/1/SAGMPRAGE*.nii.gz),
# (/datadir/10107/fmri_year2*.nii.gz,	/datadir/10107/SAGMPRAGE*.nii.gz),
# (/datadir/10343/fmri_year2*.nii.gz,	/datadir/10343/SAGMPRAGE*.nii.gz),
# (/datadir/1/fmri_year2*.nii.gz,		/datadir/1/SAGMPRAGE*.nii.gz)]
#
0.0:input:[{base}/{subject}/{fmri}*.nii*,{base}/{subject}/SAGMPRAGE*.nii*] = ({base}*{subject}*{fmri})
0.1:proc:[t1_in_fmri.nii.gz,trans.mat] = flirt -in {<0} -ref {<1} -out {>t1_in_fmri.nii.gz} -tfm {>trans.mat}
0.2:proc:[fmri_in_t1.nii.gz] = flirt -init {<1} -ref {<0.0:1} -inv -out {>fmri_in_t1.nii.gz}

#foreach t1 in subject:
#    foreach d in dti:
#      flirt -in t1 -ref d -out t1_in_fmri -tfm trans.mat
1.0:i:[{base}/{subject}/{dti}.nii.gz,{base}/{subject}/SAGMPRAGE.nii.gz] = ({base}*{subject}*{dti})
1.1:p:[trans.mat] = flirt -in {<0} -ref {<1} -out {>t1_in_fmri.nii.gz} -tfm {>out.tfm}

#combine corresponding elements from two lists
#foreach base:
#foreach subject:
#	foreach f,d in zip(fmri,dti):
#		divide -i f -i d -o ratio
#
#({base}*{subject}*({fmri},{dti})) expands to:
# (/datadir,10107,fmri_year1,dti_year1),
# (/datadir,10343,fmri_year1,dti_year1),
# (/datadir,1,fmri_year1,dti_year1),
# (/datadir,10107,fmri_year1,dti_year1),
# (/datadir,10343,fmri_year1,dti_year1),
# (/datadir,1,fmri_year1,dti_year1)
#
# then the outputs (arguments) list will be
#[(/datadir/10107/fmri_year1*.nii.gz,	/datadir/10107/dti_year1*.nii.gz),
# (/datadir/10343/fmri_year1*.nii.gz,	/datadir/10343/dti_year1*.nii.gz),
# (/datadir/1/fmri_year1*.nii.gz,		/datadir/1/dti_year1*.nii.gz),
# (/datadir/10107/fmri_year2*.nii.gz,	/datadir/10107/dti_year2*.nii.gz),
# (/datadir/10343/fmri_year2*.nii.gz,	/datadir/10343/dti_year2*.nii.gz),
# (/datadir/1/fmri_year2*.nii.gz,		/datadir/1/dti_year2*.nii.gz)]

2.0:i:[{base}/{subject}/{fmri}*.nii.gz,{base}/{subject}/{dti}*.nii.gz] = ({base}*{subject}*({fmri},{dti}))
2.1:p:[ratio.nii.gz] = divide -i {<0} -i {<1} -o {>ratio.nii.gz}

##register between corresponding fMRI across subjects (collapse subjects)
#foreach fmri:
#	flirt -in fsubj1 -ref fsubj2 -out fsubj1_in_fsubj2 -tfm trans.mat
#
# ({base}*{fmri}*{subject})  - generates every possible combination:
# (/datadir,fmri_year1,10107),
# (/datadir,fmri_year1,10343),
# (/datadir,fmri_year1,1)
# (/datadir,fmri_year2,10107),
# (/datadir,fmri_year2,10343),
# (/datadir,fmri_year2,1)
#
# Then the term in the output array: '{base}/{subject}/{fmri}*.nii.gz%{subject}'
# expands arguments across the subjects, so the argument list for job 0 is:
#[(/datadir,fmri_year1,10107),
# (/datadir,fmri_year1,10343),
# (/datadir,fmri_year1,1)]
#
# for job 1 (the second) it is:
#[(/datadir,fmri_year2,10107),
# (/datadir,fmri_year2,10343),
# (/datadir,fmri_year2,1)]
#
# even though 6 variants are generated, only 2 jobs are created

3.0:i:[{base}/{subject}/{fmri}*.nii.gz%{subject}] = ({base}*{fmri}*{subject})
3.1:p:[fsubj1_in_fsubj2.nii.gz,trans.mat] = flirt -in {<0} -i {<1} -o {>fsubj1_in_fsubj2} -tfm {>trans.mat}

###### FUTURE ############
#### create a lot of outputs
###foreach subj:
###	fslsplit fmri_0 basename -t
### This would generate a runtime-determined number of outputs
##5.0:i:[{base}/{subject}/{fmri}*.nii.gz] = ({base}*{fmri}*{subject})
##5.1:p:[odir/*] = fslsplit {0} [odir/*] basename -t
##5.2:p:[fmri] = fslmerge -t [fmri] {} #{5.1:} could also be used as input 
##5.3:p:[fmri_t0t5] = fslmerge -t [fmri] {5.1:0-5} # just get the first 5 volumes
##
### takes the first 5 inputs from 5.1, prepends -add then puts them on the CLI
### produces fslmaths -add sutch that it produces:
### $ fslmaths fmri0.nii.gz -add fmri1.nii.gz -add fmri2.nii.gz -add fmri3.nii.gz sum.nii.gz
##5.3:p:[sum] = fslmaths {5.1:0} {5.1:1-3@-add } [sum] 
##
##5 :source: [outspec[,outspec[...]]] = script.ent {<blah} {<blah} {>outspec} 
